<!-- src/svg_scale.html -->
<script>
/* ==============================================
 * バネばかり／選択メーター／てんびん  アセット
 * 依存: window.SVG  (共通ヘルパ)
 * ============================================== */
(function (SVG) {

  /* ---------- 円弧メーター描画（枠内に必ず収まる幾何） ---------- */
  function renderScale(opts){
    // opts: {max, step, value, width, height, compact, showValue}
    var W = opts.width  || 280;
    var H = opts.height || 190;
    var svg = SVG.svg(W, H);
    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

    var compact = !!opts.compact;                  // 小型（4択カード用）

    // 余白（外枠とラベル用）
    var padX = compact ? 8 : 12;
    var padY = compact ? 8 : 12;

    // 外枠（小型は省略）
    if (!compact){
      svg.appendChild(SVG.el('rect', {
        x:padX, y:padY, width:W - padX*2, height:H - padY*2, rx:12, ry:12,
        fill:'#fff', stroke:'#374151', 'stroke-width':1.6
      }));
    }

    // 幾何：中心は「内側下辺上」に置く（= はみ出しにくい）
    var cx = W/2;
    var yBottom = H - padY;        // 内側下端
    var cy = yBottom;

    // 目盛の外側オフセットと安全余白
    var tickOffset = compact ? 10 : 18;   // 旧コードのベース値を流用
    var safe = compact ? 2 : 4;

    // 「右端」「上端」に収めるための R の上限
    var RlimitRight = (W - padX - safe) - cx + tickOffset;
    var RlimitTop   = (cy - (padY + safe)) + tickOffset;

    // 半径（下限も少し確保して見た目を安定）
    var R = Math.max(28, Math.min(RlimitRight, RlimitTop));

    var max = opts.max, step = opts.step;
    var value = Math.max(0, Math.min(max, (opts.value || 0)));

    // 目盛（左=0 → 上=中間 → 右=最大 の半円）
    var totalTicks = Math.round(max / step);
    for (var i=0; i<=totalTicks; i++){
      var g = i * step;
      var ratio = i / totalTicks;                // 0..1
      var ang = (-Math.PI) + (Math.PI * ratio);

      // 1本の長さ（強調間隔）
      var len = compact ? 7 : 8;
      if ((max === 1000 && g % 100 === 0) || (max === 2000 && g % 200 === 0)) {
        len = compact ? 11 : 13;
      }

      // 外側/内側の点（外側が枠内に収まるよう R を決定済）
      var outer = R - tickOffset;
      var inner = outer - len;

      var x1 = cx + Math.cos(ang) * outer;
      var y1 = cy + Math.sin(ang) * outer;
      var x2 = cx + Math.cos(ang) * inner;
      var y2 = cy + Math.sin(ang) * inner;

      svg.appendChild(SVG.el('line', {x1:x1, y1:y1, x2:x2, y2:y2, stroke:'#111'}));

      // 主要ラベル
      var showMajor =
        (g === 0) || (g === max) ||
        (!compact && (max === 1000 && g % 200 === 0)) ||
        (!compact && (max === 2000 && g % 500 === 0)) ||
        ( compact && g === Math.round(max/2) );

      if (showMajor){
        var rLabel = compact ? (outer - 12) : (outer - 18);
        var lx = cx + Math.cos(ang) * rLabel;
        var ly = cy + Math.sin(ang) * rLabel + 4;
        var txt = (max === 2000 && g % 1000 === 0) ? (g/1000) + 'kg'
                 : (g === 0 ? '0' : g + 'g');

        svg.appendChild(SVG.text(lx, ly, txt, {
          'font-size': compact ? 10 : 11, fill:'#111', 'text-anchor':'middle'
        }));
      }
    }

    // 針（外側から少し内側に）
    var angV = (-Math.PI) + Math.PI * (value / max);
    var rNeedle = (compact ? outer - 2 : outer - 6);
    var nx = cx + Math.cos(angV) * rNeedle;
    var ny = cy + Math.sin(angV) * rNeedle;

    svg.appendChild(SVG.el('line', {
      x1:cx, y1:cy, x2:nx, y2:ny,
      stroke:'#2563eb', 'stroke-width': compact ? 2.6 : 3.2
    }));
    svg.appendChild(SVG.el('circle', {cx:cx, cy:cy, r: compact ? 4 : 5, fill:'#2563eb'}));

    // 値（大きい図のみ表示、枠の内側ギリギリに載せる）
    if (opts.showValue !== false && !compact){
      var label = (max >= 2000 && value % 1000 === 0) ? (value/1000) + 'kg' : (value + 'g');
      svg.appendChild(SVG.text(cx, H - padY - 12, label, {
        'font-size': 13, fill:'#374151', 'text-anchor':'middle'
      }));
    }
    return svg;
  }

  /* ---------- 4択：小型メーター横並び（上下クリアランス確保） ---------- */
  function renderScalePick(conf){
    // conf: {max, step, correct, deltas?[], width?, height?}
    var W = conf.width || 720;
    var H = conf.height || 230;              // 以前より高め
    var gap = 16, cols = 4;
    var cardW = (W - gap*(cols+1)) / cols;
    var cardH = H - 40;                      // 下にラベル用の空間を確保
    var svg = SVG.svg(W, H);
    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

    var choices = ['ア','イ','ウ','エ'];

    // 正解±2目盛、0、−4目盛（2kg/50gなら ±100g/−200g になる）
    var unit = conf.step;
    var deltas = conf.deltas || [-2*unit, +2*unit, 0, -4*unit];
    var values = [
      conf.correct + deltas[0],
      conf.correct + deltas[1],
      conf.correct + deltas[2],
      conf.correct + deltas[3],
    ];

    for (var i=0;i<4;i++){
      var x = gap + i*(cardW+gap), y = 10;

      // 台
      svg.appendChild(SVG.el('rect', {
        x:x, y:y, width:cardW, height:cardH, rx:12, ry:12, fill:'#fff'
      }));

      // 小メーター（上寄せで、下のラベルと衝突しないように少し余裕）
      var meter = renderScale({
        width:  cardW - 16,
        height: cardH - 26,
        max: conf.max,
        step: conf.step,
        value: values[i],
        compact: true,
        showValue: false
      });
      meter.setAttribute('x', x + 8);
      meter.setAttribute('y', y + 6);
      svg.appendChild(meter);

      // ラベル（下中央）
      svg.appendChild(SVG.text(x + cardW/2, y + cardH - 6, choices[i], {
        'font-size': 14, fill:'#2563eb', 'text-anchor':'middle'
      }));
    }
    return svg;
  }

  /* ---------- てんびん（左右どちらが軽いか） ---------- */
  function renderBalanceTilt(opts){
    var W = opts.width||460, H = opts.height||180;
    var svg = SVG.svg(W,H);
    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

    var cx=W/2, baseY=H-28;

    // 支点
    svg.appendChild(SVG.el('path',{d:`M ${cx-18} ${baseY} L ${cx} ${baseY-26} L ${cx+18} ${baseY} Z`, fill:'#9ca3af'}));

    // ビーム
    var tilt = (opts.rightIsLight!==false) ? -11 : 11;
    var beamLen = W*0.72;
    svg.appendChild(SVG.el('rect',{
      x:cx-beamLen/2, y:baseY-74, width:beamLen, height:6,
      transform:`rotate(${tilt} ${cx} ${baseY-71})`,
      rx:3, ry:3, fill:'#374151'
    }));

    // 皿
    function pan(cx0, up){
      var y = baseY-42 + (up? -16: 16);
      var g = SVG.el('g',{});
      g.appendChild(SVG.el('line',{x1:cx0,y1:baseY-70,x2:cx0,y2:y-6,stroke:'#374151'}));
      g.appendChild(SVG.el('rect',{x:cx0-46,y:y,width:92,height:11,rx:6,ry:6,fill:'#e5e7eb',stroke:'#374151'}));
      return g;
    }
    var leftUp  = (tilt>0), rightUp = (tilt<0);
    svg.appendChild(pan(cx-beamLen/2+40, leftUp));
    svg.appendChild(pan(cx+beamLen/2-40, rightUp));

    // ラベル
    svg.appendChild(SVG.text(cx-beamLen/2+40, baseY-10, 'ア', {'font-size':14, fill:'#2563eb','text-anchor':'middle'}));
    svg.appendChild(SVG.text(cx+beamLen/2-40, baseY-10, 'イ', {'font-size':14, fill:'#2563eb','text-anchor':'middle'}));

    if (opts.diffCoins){
      svg.appendChild(SVG.text(W-10, 18, `右に${opts.diffCoins}こ のせる`, {'font-size':12, fill:'#374151', 'text-anchor':'end'}));
    }
    return svg;
  }

  /* ---------- レジストリ ---------- */
  function parse(spec){
    // scale-1k-20-340 / scale-2k-50-1200
    var m1 = spec.match(/^(:?svg:)?scale-(1k|2k)-(\d+)-(\d+)$/);
    if (m1) return {kind:'scale', max:(m1[2]==='1k'?1000:2000), step:+m1[3], value:+m1[4]};

    // scale-pick-1k-20-430 など
    var m2 = spec.match(/^(:?svg:)?scale-pick-(1k|2k)-(\d+)-(\d+)$/);
    if (m2) return {kind:'pick', max:(m2[2]==='1k'?1000:2000), step:+m2[3], correct:+m2[4]};

    // balance-tilt-3
    var m3 = spec.match(/^(:?svg:)?balance-tilt-(\d+)$/);
    if (m3) return {kind:'balance', diff:+m3[2]};

    return null;
  }

  SVG.register(function(spec){
    var p = parse(spec);
    if (!p) return null;

    if (p.kind==='scale'){
      return renderScale({max:p.max, step:p.step, value:p.value});
    }

    if (p.kind==='pick'){
      // 既定の4択パターン：±2目盛、0、−4目盛（2kg/50gでも自然にずれる）
      return renderScalePick({max:p.max, step:p.step, correct:p.correct});
    }

    if (p.kind==='balance'){
      return renderBalanceTilt({diffCoins:p.diff, rightIsLight:true});
    }
    return null;
  });

})(window.SVG);
</script>
